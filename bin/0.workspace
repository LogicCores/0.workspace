#!/usr/bin/env node

var LIB = {
    VERBOSE: (!!process.env.VERBOSE) || false,
    path: require("path"),
    fs: require("fs-extra"),
    minimist: require("minimist"),
    request: require("request"),
    semver: require("semver"),
    "cli-table": require("cli-table"),
    Promise: require("bluebird"),
    colors: require("colors"),
    child_process: require("child_process")
};
LIB.Promise.promisifyAll(LIB.fs);
LIB.fs.existsAsync = function (path) {
    return new LIB.Promise(function (resolve, reject) {
        return LIB.fs.exists(path, resolve);
    });
}
LIB.Promise.promisifyAll(LIB.request);

function runCommands (commands, options) {
	return LIB.Promise.promisify(function (callback) {
	    options = options || {}
	    options.verbose = options.verbose || LIB.VERBOSE;
	    options.env = options.env || process.env;
		if (options.verbose) {
			console.log("Running commands:", commands);
			options.env.VERBOSE = "1";
		}
	    var proc = LIB.child_process.spawn("bash", [
	        "-s"
	    ], options);
	    proc.on("error", function(err) {
	    	return callback(err);
	    });
	    var stdout = [];
	    var stderr = [];
	    proc.stdout.on('data', function (data) {
	    	stdout.push(data.toString());
			if (options.verbose || options.progress) process.stdout.write(data);
	    });
	    proc.stderr.on('data', function (data) {
	    	stderr.push(data.toString());
			if (options.verbose || options.progress) process.stderr.write(data);
	    });
	    proc.stdin.write(commands.join("\n"));
	    proc.stdin.end();
	    proc.on('close', function (code) {
	    	if (code) {
	    		var err = new Error("Commands exited with code: " + code);
	    		err.code = code;
	    		err.stdout = stdout;
	    		err.stderr = stderr;
	    		console.error("err", err);
	    		return callback(err);
	    	}
	        return callback(null, stdout.join(""));
	    });
	})();
}


exports.main = function (argv) {

    const REMOTE_SOURCE_REVISIONS_URL = "https://api.github.com/repos/0system/0system.0/tags";
    const LOCAL_INSTALLS_PATH = LIB.path.join(process.env.BO_SYSTEM_CACHE_DIR, "github.com~0system~0system.0~/source/snapshot");

    function showUsage () {
        var lines = [];
        lines.push("");
        lines.push("Workspace Manager:".bold + " https://github.com/LogicCores/0.workspace".blue);
        lines.push("for Zero System:".bold + " https://github.com/0system".blue);
        lines.push("");
        lines.push("Usage: ");
        lines.push("");
        lines.push("  0w init [--inject-scripts]      Add Zero System to a new or existing git project");
        lines.push("  0w current                      Display currently activated version");
        lines.push("  0w ls                           List installed versions");
        lines.push("  0w ls-remote                    List remote versions available for install");
        lines.push("  0w install <version/uri>        Download and install a <version/uri>");
        lines.push("  0w use <version/path>           Modify 'package.json' and './.0' to use <version/path>");
        lines.push("");
        lines.push("  0w update                       Pull changes, checkout submodules and re-install");
        lines.push("  0w edit                         Launch an editor");
        lines.push("  0w dev                          Run system in development mode using development profile");
        lines.push("  0w dev --production             Run system in production mode using production profile");
        lines.push("  0w dev -- --profile ./Deployments/<name>.proto.profile.ccjson");
        lines.push("                                  Run system in development mode using custom profile overlay");
        lines.push("  0w encrypt                      Encrypt raw profile data using workspace secret");
        lines.push("  0w test                         Run whole system test suite");
        lines.push("");
        lines.push("  0w bundle                       Freeze everything for consistent distribution");
        lines.push("  0w deploy                       Deploy latest commit to staging");
        lines.push("  0w deploy --production          Deploy latest commit to production");
        lines.push("  0w publish                      Publish latest commit");
        lines.push("");
        lines.push("  0w start                        Run system in production mode using production profile");
        lines.push("");
        process.stdout.write(lines.join("\n") + "\n");
        return LIB.Promise.resolve();
    }
    
    function loadCurrentStatus () {
        function lookup (path) {
            path = LIB.path.join(path, ".0");
            return LIB.fs.existsAsync(path).then(function (exists) {
                if (!exists) {
                    return null;
                };
                return LIB.fs.lstatAsync(path).then(function (stat) {
                    if (!stat.isSymbolicLink()) {
                        if (stat.isDirectory()) {
                            return lookup(path);
                        }
                        return LIB.fs.readFileAsync(path, "utf8").then(function (data) {
                            if (data === ".") {
                                return LIB.fs.realpathAsync(path);
                            }
                            return lookup(data);
                        });
                    }
                    return LIB.fs.readlinkAsync(path).then(lookup);
                });
            });
        }
        return lookup(
            process.cwd()
        ).then(function (path) {
            var status = {
                path: null,
                version: null
            };
            if (!path) {
                return status;
            }
            status.path = LIB.path.dirname(path);
    		return runCommands([
    		   'echo "tag: $(git describe --tags)"'
    		], {
    		    cwd: status.path,
    		    verbose: LIB.VERBOSE
    		}).then(function (stdout) {
    		    status.version = stdout.match(/^tag: (.+)$/m)[1];
                return status;
    		});
        });
    }

    function isRemoteTagEqualToLocalTag (remoteTag, localTag) {
        var remote = remoteTag.match(/^(v\d+\.\d+\.\d+)-([^\.]+)(\.\d+\.(.+))?$/);
        var local = localTag.match(/^(v\d+\.\d+\.\d+)(-\d+-(.+))?$/);
        if (remote[4] === local[3]) {
            return true;
        }
        if (
            remote[1] === local[1] &&
            remote[2] === "inline" &&
            !local[2]
        ) {
            return true;
        }
        return false;
    }

    function loadRemote () {
        return LIB.request.getAsync(REMOTE_SOURCE_REVISIONS_URL, {
            headers: {
                "User-Agent": "github.com/LogicCores/0.workspace using npm/request"
            },
            json: true
        }).then(function (response) {
            var tags = [];
            response.body.forEach(function (tag) {
                tags.push(tag.name);
            });
            tags = LIB.semver.sort(tags);
            tags.reverse();
            tags = tags.map(function (tag) {
                var m = tag.match(/^v\d+\.\d+\.\d+-(inline|build)\.?/);
                tag = {
                    tag: tag,
                    isUsing: function (status) {
                        if (!status.version) return "";
                        if (isRemoteTagEqualToLocalTag(tag.tag, status.version)) {
                            return "  *";
                        }
                        return "";
                    }
                };
                if (m) {
                    tag.stream = m[1];
                }
                if (tag.stream === "inline") {
                    tag.stability = "preview";
                } else {
                    tag.stability = tag.stream;
                }
                return tag;
            }).filter(function (tag) {
                return !!tag.stream;
            });
            return tags;
        });
    }

    function loadInstalled () {
        var installs = [];
        return LIB.fs.existsAsync(LOCAL_INSTALLS_PATH).then(function (exists) {
            if (!exists) {
                return installs;
            }
            return LIB.fs.readdirAsync(LOCAL_INSTALLS_PATH).then(function (paths) {
                paths.forEach(function (filename) {
                    installs.push({
                        tag: filename,
                        isUsing: function (status) {
                            if (!status.version) return "";
                            if (isRemoteTagEqualToLocalTag(filename, status.version)) {
                                return "  *";
                            }
                            return "";
                        }
                    });
                });
                return null;
            });
        }).then(function () {
            return installs;
        });
    }

    var command = argv["_"].shift() || "";
    
    if (argv["help"] || argv["h"]) {
        return showUsage();
    }

    if (argv["verbose"] || argv["v"]) {
        LIB.VERBOSE = true;
    }

    function runDefault () {

// TODO: See if we can find a workspace script for the command and run that
/*
        lines.push("  0w update                  Pull changes, checkout submodules and re-install");
        lines.push("  0w edit                    Launch an editor");
        lines.push("  0w dev                     Run system in development mode using development profile");
        lines.push("  0w dev --production        Run system in production mode using production profile");
        lines.push("  0w dev -- --profile ./Deployments/<name>.proto.profile.ccjson");
        lines.push("                                      Run system in development mode using custom profile overlay");
        lines.push("  0w encrypt                 Encrypt raw profile data using workspace secret");
        lines.push("  0w test                    Test system");
        lines.push("");
        lines.push("  0w bundle                  Freeze everything for consistent distribution");
        lines.push("  0w deploy                  Deploy latest commit to staging");
        lines.push("  0w deploy --production     Deploy latest commit to production");
        lines.push("  0w publish                 Publish latest commit");
        lines.push("");
        lines.push("  0w start                   Run system in production mode using production profile");
        lines.push("");
*/

        return LIB.Promise.try(function () {


console.log("TODO: Run default command:", command);


            process.stdout.write(("\nError: Command '" + command + "' not found!\n").red);
            return showUsage();
        });
    }

    switch (command) {

        case "init":
            return LIB.Promise.try(function () {
/*
Init

  1. Configure `./_Deployments/127.0.0.1:8090.profile.ccjson` to point to your own github application
  2. Rename and configure `./_Deployments/zerosystem-workspace.herokuapp.com.profile.ccjson` to point to your own heroku application for your workspace
  3. Rename and add remote for the heroku application `git remote add heroku git@heroku.com:zerosystem-workspace.git`

*/
            });

        case "current":
            return loadCurrentStatus().then(function (status) {
                if (!status.version) {
                    throw new Error("No release linked!");
                }
                process.stdout.write(status.version + " (" + status.path + ")\n");
                return null;
            });

        case "ls":
            return loadCurrentStatus().then(function (status) {
                return loadInstalled().then(function (tags) {
                    if (Object.keys(tags).length === 0) {
                        throw new Error("No installs found!");
                    }
                    var table = new (LIB["cli-table"])({
                        head: [
                            'Using', 'Tag'
                        ],
                        chars: {'mid': '', 'left-mid': '', 'mid-mid': '', 'right-mid': ''}
                    });
                    tags.forEach(function (tag) {
                        table.push(
                            [
                                tag.isUsing(status),
                                tag.tag
                            ]
                        );
                    });
                    process.stdout.write(table.toString() + "\n");
                    return null;
                });
            });

        case "ls-remote":
            return loadCurrentStatus().then(function (status) {
                return loadRemote().then(function (tags) {
                    var table = new (LIB["cli-table"])({
                        head: [
                            'Using', 'Tag', 'Stability'
                        ],
                        chars: {'mid': '', 'left-mid': '', 'mid-mid': '', 'right-mid': ''}
                    });
                    tags.forEach(function (tag) {
                        table.push(
                            [
                                tag.isUsing(status),
                                tag.tag,
                                tag.stability
                            ]
                        );
                    });
                    process.stdout.write(table.toString() + "\n");
                    return null;
                });
            });

        case "install":
            return LIB.Promise.try(function () {
                // If no version specified we run the workspace install script.
                if (argv["_"].length === 0) {
                    return runDefault();
                }
                
                var version = argv["_"].shift();
                
                function resolveVersion (version) {
                    return loadCurrentStatus().then(function (status) {
                        if (
                            version === "latest" ||
                            /^\d+$/.test(version)
                        ) {
                            return loadRemote().then(function (tags) {
                                var tag = null;
                                if (version === "latest") {
                                    tag = tags.shift();
                                } else {
                                    tag = tags.splice(parseInt(version), 1)[0];
                                }
                                if (tag.isUsing(status)) {
                                    throw new Error("Already using the latest version!");
                                }
                                return tag.tag;
                            });
                        }
                        if (isRemoteTagEqualToLocalTag(version, status.version)) {
                            throw new Error("Already using the latest version!");
                        }
                        return version;
                    });
                }

                return resolveVersion(version).then(function (version) {
            		return runCommands([
            		    '. ' + LIB.path.join(__dirname, "./0.workspace.proto.sh"),
            		    '0.workspace.install "' + version + '"'
            		], {
            		    cwd: process.cwd(),
            		    verbose: LIB.VERBOSE
            		});
                });
            });

        case "use":
            return LIB.Promise.try(function () {
                
            });

        default:
            return runDefault();
    }
}


if (require.main === module) {
    exports.main(
        LIB.minimist(process.argv.slice(2))
    ).then(function () {
        process.exit(0);
        return null;
    }).catch(function (err) {
        if (LIB.VERBOSE) {
            console.error(("" + err.stack).red);
        } else {
            console.error(("Error: " + err.message).red);
        }
        process.exit(1);
        return null;
    });
}

